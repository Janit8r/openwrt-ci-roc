name: Extract DTB from OpenWrt Image

on:
  workflow_dispatch:
    inputs:
      image_url:
        description: 'OpenWrt image URL or file name'
        required: true
        default: 'openwrt-rockchip-ts3200-ext4-sysupgrade-v3.02-a0d7a9ef.img.gz'
      upload_artifact:
        description: 'Upload extracted files as artifact'
        required: false
        default: 'true'

env:
  TZ: Asia/Shanghai

jobs:
  Extract:
    runs-on: ubuntu-24.04

    steps:
    - name: Checkout(检出代码)
      uses: actions/checkout@main

    - name: Initialization Environment(初始化环境)
      env:
        DEBIAN_FRONTEND: noninteractive
      run: |
        sudo -E apt-get -y update
        sudo -E apt-get -y install gzip file binwalk device-tree-compiler kpartx util-linux
        sudo timedatectl set-timezone "$TZ"

    - name: Download Image(下载镜像)
      run: |
        mkdir -p workspace
        cd workspace
        IMAGE_INPUT="${{ github.event.inputs.image_url }}"
        
        # 判断是URL还是文件名
        if [[ "$IMAGE_INPUT" =~ ^https?:// ]]; then
          echo "Downloading from URL: $IMAGE_INPUT"
          wget -O image.img.gz "$IMAGE_INPUT" || curl -L -o image.img.gz "$IMAGE_INPUT"
        else
          echo "Using file name: $IMAGE_INPUT"
          # 如果是文件名，假设在当前目录或需要从某处下载
          if [ -f "../$IMAGE_INPUT" ]; then
            cp "../$IMAGE_INPUT" image.img.gz
          elif [ -f "$IMAGE_INPUT" ]; then
            cp "$IMAGE_INPUT" image.img.gz
          else
            echo "File not found locally, trying to download from common sources..."
            # 尝试从常见的OpenWrt源下载
            wget -O image.img.gz "https://downloads.openwrt.org/$IMAGE_INPUT" || \
            wget -O image.img.gz "https://mirror.iscas.ac.cn/openwrt/$IMAGE_INPUT" || \
            echo "Error: File not found and unable to download"
          fi
        fi
        
        # 检查文件是否存在
        if [ ! -f "image.img.gz" ]; then
          echo "Error: Image file not found"
          exit 1
        fi
        
        echo "IMAGE_FILE=image.img.gz" >> $GITHUB_ENV
        echo "Downloaded/copied image:"
        ls -lh image.img.gz
        file image.img.gz

    - name: Extract Image(解压镜像)
      run: |
        cd workspace
        echo "Extracting gzip archive..."
        
        # gunzip可能会报告trailing garbage，但这是正常的，使用|| true忽略错误
        gunzip -k $IMAGE_FILE 2>&1 || true
        
        IMAGE_EXTRACTED="${IMAGE_FILE%.gz}"
        echo "IMAGE_EXTRACTED=$IMAGE_EXTRACTED" >> $GITHUB_ENV
        
        # 检查解压后的文件是否存在
        if [ ! -f "$IMAGE_EXTRACTED" ]; then
          echo "Error: Failed to extract image"
          exit 1
        fi
        
        echo "Image file info:"
        file $IMAGE_EXTRACTED
        ls -lh $IMAGE_EXTRACTED

    - name: Analyze Image Structure(分析镜像结构)
      run: |
        cd workspace
        echo "=== Image Structure Analysis ==="
        
        # 显示分区表
        echo "Partition table:"
        fdisk -l $IMAGE_EXTRACTED || true
        
        # 使用binwalk分析
        echo -e "\n=== Binwalk Analysis ==="
        binwalk $IMAGE_EXTRACTED | tee binwalk_output.txt
        
        # 使用file命令
        echo -e "\n=== File Type ==="
        file $IMAGE_EXTRACTED

    - name: Mount and Extract Partitions(挂载并提取分区)
      run: |
        cd workspace
        echo "Creating loop device..."
        
        # 创建loop设备
        sudo losetup -fP $IMAGE_EXTRACTED || true
        LOOP_DEV=$(losetup -j $IMAGE_EXTRACTED | cut -d: -f1)
        
        if [ -z "$LOOP_DEV" ]; then
          echo "Warning: Failed to create loop device, will try alternative methods"
        else
          echo "Loop device: $LOOP_DEV"
          echo "LOOP_DEV=$LOOP_DEV" >> $GITHUB_ENV
          
          # 列出分区
          echo "Available partitions:"
          ls -l ${LOOP_DEV}* 2>/dev/null || true
          lsblk $LOOP_DEV 2>/dev/null || true
        fi
        
        # 创建挂载点
        mkdir -p boot rootfs extracted
        
        # 尝试挂载boot分区（通常是第一个分区）
        if [ -n "$LOOP_DEV" ] && [ -e "${LOOP_DEV}p1" ]; then
          echo "Mounting ${LOOP_DEV}p1 to boot/"
          sudo mount ${LOOP_DEV}p1 boot/ 2>/dev/null && echo "Boot partition mounted successfully" || echo "Failed to mount p1"
        fi
        
        # 尝试挂载rootfs分区（通常是第二个分区）
        if [ -n "$LOOP_DEV" ] && [ -e "${LOOP_DEV}p2" ]; then
          echo "Mounting ${LOOP_DEV}p2 to rootfs/"
          sudo mount ${LOOP_DEV}p2 rootfs/ 2>/dev/null && echo "Rootfs partition mounted successfully" || echo "Failed to mount p2"
        fi
        
        # 显示挂载的内容
        echo -e "\n=== Boot partition contents ==="
        if mountpoint -q boot/; then
          ls -lah boot/ 2>/dev/null || true
        else
          echo "Boot partition not mounted"
        fi
        
        echo -e "\n=== Rootfs partition contents (top level) ==="
        if mountpoint -q rootfs/; then
          ls -lah rootfs/ 2>/dev/null || true
        else
          echo "Rootfs partition not mounted"
        fi

    - name: Extract DTB Files(提取DTB文件)
      run: |
        cd workspace
        echo "=== Searching for DTB files ==="
        
        # 在boot分区查找DTB
        if [ -d "boot" ]; then
          echo "Searching in boot partition..."
          sudo find boot/ -name "*.dtb" -exec cp {} extracted/ \; 2>/dev/null || true
        fi
        
        # 在rootfs分区查找DTB
        if [ -d "rootfs" ]; then
          echo "Searching in rootfs partition..."
          sudo find rootfs/ -name "*.dtb" -exec cp {} extracted/ \; 2>/dev/null || true
          sudo find rootfs/boot -name "*.dtb" -exec cp {} extracted/ \; 2>/dev/null || true
        fi
        
        # 使用binwalk识别DTB位置
        echo -e "\n=== Extracting DTB using binwalk ==="
        binwalk $IMAGE_EXTRACTED | grep "Flattened device tree" | tee dtb_locations.txt
        
        # 手动提取DTB文件
        echo -e "\n=== Manually extracting DTB files ==="
        DTB_COUNT=0
        while IFS= read -r line; do
          # 提取偏移量和大小
          OFFSET=$(echo "$line" | awk '{print $1}')
          SIZE=$(echo "$line" | grep -oP 'size: \K[0-9]+')
          
          if [ -n "$OFFSET" ] && [ -n "$SIZE" ]; then
            DTB_COUNT=$((DTB_COUNT + 1))
            OUTPUT_FILE="extracted/dtb_${OFFSET}.dtb"
            echo "Extracting DTB at offset $OFFSET, size $SIZE bytes to $OUTPUT_FILE"
            dd if=$IMAGE_EXTRACTED of=$OUTPUT_FILE bs=1 skip=$OFFSET count=$SIZE 2>/dev/null
          fi
        done < dtb_locations.txt
        
        echo "Extracted $DTB_COUNT DTB files"
        
        # 也尝试使用binwalk自动提取
        binwalk -e $IMAGE_EXTRACTED 2>/dev/null || true
        
        # 查找binwalk提取的文件
        if [ -d "_${IMAGE_EXTRACTED}.extracted" ]; then
          sudo find "_${IMAGE_EXTRACTED}.extracted" -name "*.dtb" -exec cp {} extracted/ \; 2>/dev/null || true
          # 查找可能的DTB文件（没有扩展名的）
          sudo find "_${IMAGE_EXTRACTED}.extracted" -type f -size +1k -size -200k -exec file {} \; | grep "Device Tree Blob" | cut -d: -f1 | while read dtbfile; do
            sudo cp "$dtbfile" extracted/$(basename "$dtbfile").dtb 2>/dev/null || true
          done
        fi
        
        # 修改权限
        sudo chown -R $(id -u):$(id -g) extracted/
        
        echo -e "\n=== Extracted DTB files ==="
        ls -lh extracted/
        
        # 分析DTB文件
        if [ -n "$(ls -A extracted/*.dtb 2>/dev/null)" ]; then
          for dtb in extracted/*.dtb; do
            echo -e "\n=== Analyzing $dtb ==="
            file "$dtb"
            
            # 验证DTB文件
            if file "$dtb" | grep -q "Device Tree Blob"; then
              echo "Valid DTB file detected"
              # 反编译DTB为DTS
              dtc -I dtb -O dts "$dtb" -o "${dtb%.dtb}.dts" 2>/dev/null && echo "Decompiled to ${dtb%.dtb}.dts" || echo "Failed to decompile $dtb"
              
              # 提取DTB信息
              echo "DTB Info:"
              fdtget "$dtb" / compatible 2>/dev/null || echo "No compatible property found"
              fdtget "$dtb" / model 2>/dev/null || echo "No model property found"
            else
              echo "Warning: $dtb may not be a valid DTB file"
            fi
          done
        else
          echo "No DTB files found!"
        fi
        
        # 列出所有提取的文件
        echo -e "\n=== All extracted files ==="
        ls -lh extracted/

    - name: Extract Kernel and Other Components(提取内核和其他组件)
      run: |
        cd workspace
        echo "=== Extracting kernel and other components ==="
        
        # 使用binwalk提取所有可识别的组件
        binwalk -e $IMAGE_EXTRACTED || true
        
        # 查找内核镜像和其他组件
        if [ -d "_${IMAGE_EXTRACTED}.extracted" ]; then
          echo "Binwalk extracted files:"
          ls -lh "_${IMAGE_EXTRACTED}.extracted"
          
          # 挂载提取的ext文件系统来查找内核
          echo -e "\n=== Mounting extracted filesystems ==="
          for extfs in "_${IMAGE_EXTRACTED}.extracted"/*.ext*; do
            if [ -f "$extfs" ]; then
              MOUNT_DIR="mount_$(basename $extfs)"
              mkdir -p "$MOUNT_DIR"
              echo "Mounting $extfs to $MOUNT_DIR"
              sudo mount -o loop,ro "$extfs" "$MOUNT_DIR" 2>/dev/null && {
                echo "Contents of $extfs:"
                ls -lah "$MOUNT_DIR"
                
                # 查找内核镜像
                sudo find "$MOUNT_DIR" -type f \( -name "*Image*" -o -name "*vmlinuz*" -o -name "*zImage*" -o -name "*kernel*" \) -exec cp {} extracted/ \; 2>/dev/null || true
                
                # 查找DTB文件
                sudo find "$MOUNT_DIR" -name "*.dtb" -exec cp {} extracted/ \; 2>/dev/null || true
                
                sudo umount "$MOUNT_DIR" 2>/dev/null || true
              } || echo "Failed to mount $extfs"
            fi
          done
          
          # 复制有用的文件到extracted目录
          sudo find "_${IMAGE_EXTRACTED}.extracted" -type f \( -name "*kernel*" -o -name "*zImage*" -o -name "*Image*" \) -exec cp {} extracted/ \; 2>/dev/null || true
        fi
        
        sudo chown -R $(id -u):$(id -g) extracted/
        
        echo -e "\n=== Final extracted files ==="
        ls -lh extracted/
        du -sh extracted/

    - name: Create Summary(创建摘要)
      run: |
        cd workspace
        echo "=== Extraction Summary ===" | tee summary.txt
        echo "" | tee -a summary.txt
        echo "Image: ${{ github.event.inputs.image_url }}" | tee -a summary.txt
        echo "Date: $(date)" | tee -a summary.txt
        echo "" | tee -a summary.txt
        echo "Extracted files:" | tee -a summary.txt
        ls -lh extracted/ | tee -a summary.txt
        echo "" | tee -a summary.txt
        
        if [ -f "binwalk_output.txt" ]; then
          echo "Binwalk analysis:" | tee -a summary.txt
          cat binwalk_output.txt | tee -a summary.txt
        fi
        
        cat summary.txt

    - name: Cleanup(清理)
      if: always()
      run: |
        cd workspace
        # 卸载分区
        if [ -n "$LOOP_DEV" ]; then
          sudo umount boot/ 2>/dev/null || true
          sudo umount rootfs/ 2>/dev/null || true
          sudo losetup -d $LOOP_DEV 2>/dev/null || true
        fi

    - name: Upload Extracted Files(上传提取的文件)
      if: github.event.inputs.upload_artifact == 'true'
      uses: actions/upload-artifact@main
      with:
        name: extracted-dtb-$(date +"%Y%m%d")
        path: |
          workspace/extracted/
          workspace/summary.txt
          workspace/binwalk_output.txt

    - name: Upload to Release(发布到Release)
      if: github.event.inputs.upload_artifact == 'true'
      uses: ncipollo/release-action@main
      with:
        name: DTB Extraction - $(date +"%Y-%m-%d %H:%M:%S")
        allowUpdates: true
        tag: dtb-extraction
        token: ${{ secrets.GITHUB_TOKEN }}
        artifacts: workspace/extracted/*
        body: |
          ## DTB Extraction Results
          
          **Source Image:** ${{ github.event.inputs.image_url }}
          
          **Extraction Date:** $(date +"%Y-%m-%d %H:%M:%S")
          
          ### Extracted Files
          
          This release contains DTB (Device Tree Blob) files and other components extracted from the OpenWrt firmware image.
          
          - DTB files: `*.dtb`
          - Decompiled DTS files: `*.dts`
          - Other components: kernel, bootloader, etc.
          
          ### Usage
          
          DTB files can be used for:
          - Device tree analysis
          - Hardware configuration reference
          - Custom firmware development
          
          Check the summary.txt for detailed extraction information.
